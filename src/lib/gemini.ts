/**
 * CDSS - Gemini AI Service
 * Clinical Decision Support powered by Google Gemini
 */

import type {
    DiagnosticAnalysis,
    DifferentialDiagnosis,
    RedFlag,
    SuggestedTest,
    TreatmentPathway,
    ExplainableReasoning,
    ClinicalEncounter,
    MedicalHistory,
    Patient,
    LaboratoryPanel,
    Symptom,
    VitalSigns,
} from '@/types/medical';
import { generateId, generateAuditId } from '@/lib/utils';

// Gemini API Configuration
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent';

interface GeminiResponse {
    candidates: Array<{
        content: {
            parts: Array<{
                text: string;
            }>;
        };
        finishReason: string;
    }>;
}

/**
 * Medical disclaimer that must accompany all AI outputs
 */
export const MEDICAL_DISCLAIMER = `
⚠️ CLINICAL DECISION SUPPORT DISCLAIMER

This analysis is generated by an AI system designed to ASSIST licensed medical professionals. 
It does NOT replace clinical judgment, examination, or professional medical advice.

• All suggestions require verification by a qualified healthcare provider
• AI confidence scores reflect pattern matching, not diagnostic certainty
• Critical decisions must be based on comprehensive clinical evaluation
• The system may not account for all relevant patient factors
• Always consider differential diagnoses not listed

This tool is compliant with EU medical device software guidelines and is intended 
for decision support only. Final diagnostic and treatment decisions remain the 
sole responsibility of the treating clinician.
`.trim();

/**
 * Build the clinical analysis prompt for Gemini
 */
function buildAnalysisPrompt(
    patient: Patient,
    encounter: ClinicalEncounter,
    history: MedicalHistory | null,
    labResults: LaboratoryPanel[]
): string {
    const demographics = patient?.demographics || {};

    const prompt = `You are an expert clinical decision support AI assistant helping licensed medical professionals with diagnostic reasoning. Analyze the following patient case and provide structured clinical insights.

PATIENT DEMOGRAPHICS:
- Age Range: ${demographics.ageRange || 'Unknown'}
- Biological Sex: ${demographics.biologicalSex || 'Unknown'}
${demographics.bmi ? `- BMI: ${demographics.bmi}` : ''}

CHIEF COMPLAINT:
${encounter?.chiefComplaint || 'None provided'}

CURRENT SYMPTOMS:
${encounter?.symptoms?.map(s => `- ${s.name}: ${s.description || 'No details'} (Severity: ${s.severity}/10, Duration: ${s.duration}, Onset: ${s.onset})${s.location ? `, Location: ${s.location}` : ''}`).join('\n') || 'None recorded'}

VITAL SIGNS:
${encounter?.vitals ? formatVitals(encounter.vitals) : 'No vitals recorded'}

${history ? `MEDICAL HISTORY:
${formatMedicalHistory(history)}` : ''}

${labResults.length > 0 ? `LABORATORY RESULTS:
${formatLabResults(labResults)}` : ''}

Please provide a comprehensive clinical analysis in the following JSON format:

{
  "differentialDiagnoses": [
    {
      "rank": 1,
      "condition": "Condition Name",
      "icdCode": "ICD-10 Code if known",
      "confidenceScore": 85,
      "probability": "high|moderate|low",
      "supportingEvidence": [
        {"type": "symptom|vital|lab|history|demographic", "description": "Evidence description", "weight": "strong|moderate|weak"}
      ],
      "contradictingEvidence": [
        {"type": "symptom|vital|lab|history|demographic", "description": "Evidence description", "weight": "strong|moderate|weak"}
      ],
      "additionalConsiderations": "Any important notes"
    }
  ],
  "redFlags": [
    {
      "severity": "immediate|urgent|soon",
      "description": "Red flag description",
      "associatedCondition": "Related condition if any",
      "recommendedAction": "What to do",
      "timeframe": "Time-sensitive guidance"
    }
  ],
  "suggestedTests": [
    {
      "testName": "Test Name",
      "category": "laboratory|imaging|procedure|specialist-referral",
      "priority": "stat|urgent|routine",
      "rationale": "Why this test",
      "expectedToRule": {"in": ["Conditions"], "out": ["Conditions"]}
    }
  ],
  "treatmentPathways": [
    {
      "condition": "For which condition",
      "pathway": "first-line|second-line|alternative",
      "description": "Treatment approach",
      "guidelineReference": {"name": "Guideline", "organization": "Org"},
      "considerations": ["Important considerations"],
      "contraindications": ["If any"],
      "monitoringRequirements": ["What to monitor"]
    }
  ],
  "reasoning": {
    "summaryText": "Brief summary of clinical reasoning",
    "reasoningSteps": [
      {"step": 1, "category": "Category", "description": "Step description", "evidenceUsed": ["Evidence"], "conclusion": "Step conclusion"}
    ],
    "limitations": ["Limitations of this analysis"],
    "uncertaintyFactors": ["Sources of uncertainty"]
  }
}

IMPORTANT GUIDELINES:
1. Provide 3-7 differential diagnoses ranked by clinical likelihood
2. Always include red flags if any concerning patterns are present
3. Suggest relevant diagnostic tests to confirm or rule out conditions
4. Reference clinical guidelines where applicable
5. Be explicit about uncertainty and limitations
6. Consider the patient's age, sex, and history in your analysis
7. Prioritize patient safety - err on the side of caution for red flags

Respond ONLY with the JSON object, no additional text.`;

    return prompt;
}

function formatVitals(vitals: VitalSigns): string {
    const parts: string[] = [];
    if (vitals.bloodPressureSystolic && vitals.bloodPressureDiastolic) {
        parts.push(`- Blood Pressure: ${vitals.bloodPressureSystolic}/${vitals.bloodPressureDiastolic} mmHg`);
    }
    if (vitals.heartRate) parts.push(`- Heart Rate: ${vitals.heartRate} bpm`);
    if (vitals.temperature) parts.push(`- Temperature: ${vitals.temperature}°${vitals.temperatureUnit || 'C'}`);
    if (vitals.respiratoryRate) parts.push(`- Respiratory Rate: ${vitals.respiratoryRate}/min`);
    if (vitals.oxygenSaturation) parts.push(`- SpO2: ${vitals.oxygenSaturation}%`);
    if (vitals.painLevel) parts.push(`- Pain Level: ${vitals.painLevel}/10`);
    return parts.length > 0 ? parts.join('\n') : 'No vitals recorded';
}

function formatMedicalHistory(history: MedicalHistory): string {
    const parts: string[] = [];

    if (history.conditions.length > 0) {
        parts.push('Existing Conditions:');
        history.conditions.forEach(c => {
            parts.push(`  - ${c.name} (${c.status})${c.icdCode ? ` [${c.icdCode}]` : ''}`);
        });
    }

    if (history.allergies.length > 0) {
        parts.push('Allergies:');
        history.allergies.forEach(a => {
            parts.push(`  - ${a.allergen} (${a.severity}): ${a.reaction || 'No reaction specified'}`);
        });
    }

    if (history.medications.length > 0) {
        parts.push('Current Medications:');
        history.medications.forEach(m => {
            parts.push(`  - ${m.name} ${m.dosage} ${m.frequency}`);
        });
    }

    if (history.familyHistory.length > 0) {
        parts.push('Family History:');
        history.familyHistory.forEach(f => {
            parts.push(`  - ${f.condition} (${f.relation})`);
        });
    }

    parts.push(`Lifestyle:`);
    parts.push(`  - Smoking: ${history.lifestyle.smokingStatus}`);
    parts.push(`  - Alcohol: ${history.lifestyle.alcoholUse}`);
    parts.push(`  - Exercise: ${history.lifestyle.exerciseFrequency}`);

    return parts.join('\n');
}

function formatLabResults(panels: LaboratoryPanel[]): string {
    const parts: string[] = [];

    panels.forEach(panel => {
        parts.push(`${panel.panelName}:`);
        panel.results.forEach(r => {
            const refRange = r.referenceRange.low !== undefined && r.referenceRange.high !== undefined
                ? ` (Ref: ${r.referenceRange.low}-${r.referenceRange.high})`
                : '';
            parts.push(`  - ${r.testName}: ${r.value} ${r.unit}${refRange} [${r.status}]`);
        });
    });

    return parts.join('\n');
}

/**
 * Call Gemini API for clinical analysis
 */
async function callGeminiAPI(prompt: string, apiKey: string): Promise<string> {
    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            contents: [
                {
                    parts: [
                        {
                            text: prompt,
                        },
                    ],
                },
            ],
            generationConfig: {
                temperature: 0.3, // Lower temperature for more consistent medical responses
                topK: 40,
                topP: 0.95,
                maxOutputTokens: 8192,
            },
            safetySettings: [
                {
                    category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
                    threshold: 'BLOCK_NONE', // Medical content may trigger safety filters
                },
                {
                    category: 'HARM_CATEGORY_HARASSMENT',
                    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
                },
                {
                    category: 'HARM_CATEGORY_HATE_SPEECH',
                    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
                },
                {
                    category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
                    threshold: 'BLOCK_MEDIUM_AND_ABOVE',
                },
            ],
        }),
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Gemini API error: ${response.status} - ${errorText}`);
    }

    const data: GeminiResponse = await response.json();

    if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No response from Gemini API');
    }

    return data.candidates[0].content.parts[0].text;
}

/**
 * Parse Gemini response into structured analysis
 */
function parseAnalysisResponse(responseText: string, encounterId: string): DiagnosticAnalysis {
    // Clean up the response - remove markdown code blocks if present
    let cleanedText = responseText.trim();
    if (cleanedText.startsWith('```json')) {
        cleanedText = cleanedText.slice(7);
    }
    if (cleanedText.startsWith('```')) {
        cleanedText = cleanedText.slice(3);
    }
    if (cleanedText.endsWith('```')) {
        cleanedText = cleanedText.slice(0, -3);
    }
    cleanedText = cleanedText.trim();

    try {
        const parsed = JSON.parse(cleanedText);

        // Transform and validate the response
        const analysis: DiagnosticAnalysis = {
            id: generateId(),
            encounterId,
            analyzedAt: new Date(),
            differentialDiagnoses: (parsed.differentialDiagnoses || []).map((d: any, index: number) => ({
                id: generateId(),
                rank: d.rank || index + 1,
                condition: d.condition || 'Unknown',
                icdCode: d.icdCode,
                confidenceScore: Math.min(100, Math.max(0, d.confidenceScore || 50)),
                probability: d.probability || 'moderate',
                supportingEvidence: (d.supportingEvidence || []).map((e: any) => ({
                    type: e.type || 'symptom',
                    description: e.description || '',
                    weight: e.weight || 'moderate',
                })),
                contradictingEvidence: (d.contradictingEvidence || []).map((e: any) => ({
                    type: e.type || 'symptom',
                    description: e.description || '',
                    weight: e.weight || 'moderate',
                })),
                additionalConsiderations: d.additionalConsiderations,
            })),
            redFlags: (parsed.redFlags || []).map((r: any) => ({
                id: generateId(),
                severity: r.severity || 'soon',
                description: r.description || '',
                associatedCondition: r.associatedCondition,
                recommendedAction: r.recommendedAction || 'Consult with physician',
                timeframe: r.timeframe,
            })),
            suggestedTests: (parsed.suggestedTests || []).map((t: any) => ({
                id: generateId(),
                testName: t.testName || '',
                testCode: t.testCode,
                category: t.category || 'laboratory',
                priority: t.priority || 'routine',
                rationale: t.rationale || '',
                expectedToRule: {
                    in: t.expectedToRule?.in || [],
                    out: t.expectedToRule?.out || [],
                },
            })),
            treatmentPathways: (parsed.treatmentPathways || []).map((t: any) => ({
                id: generateId(),
                condition: t.condition || '',
                pathway: t.pathway || 'first-line',
                description: t.description || '',
                guidelineReference: t.guidelineReference,
                considerations: t.considerations || [],
                contraindications: t.contraindications,
                monitoringRequirements: t.monitoringRequirements,
            })),
            reasoning: {
                summaryText: parsed.reasoning?.summaryText || 'Analysis completed.',
                reasoningSteps: (parsed.reasoning?.reasoningSteps || []).map((s: any) => ({
                    step: s.step || 1,
                    category: s.category || 'Analysis',
                    description: s.description || '',
                    evidenceUsed: s.evidenceUsed || [],
                    conclusion: s.conclusion || '',
                })),
                dataSourcesUsed: [
                    { type: 'patient-input', description: 'Symptoms and chief complaint' },
                    { type: 'vitals', description: 'Vital signs measurements' },
                    { type: 'medical-history', description: 'Patient medical history' },
                    { type: 'lab-results', description: 'Laboratory findings' },
                ],
                limitations: parsed.reasoning?.limitations || [
                    'AI analysis is based on provided information only',
                    'Physical examination findings not included',
                    'May not reflect recent medical literature',
                ],
                uncertaintyFactors: parsed.reasoning?.uncertaintyFactors || [],
            },
            modelVersion: 'AI Engine v2.0',
            disclaimers: [MEDICAL_DISCLAIMER],
            auditTrail: [
                {
                    id: generateAuditId(),
                    timestamp: new Date(),
                    action: 'ai-analysis-requested',
                    actorId: 'system',
                    actorRole: 'AI Engine',
                    resourceType: 'DiagnosticAnalysis',
                    resourceId: encounterId,
                    details: 'Gemini AI analysis initiated',
                },
            ],
        };

        return analysis;
    } catch (error) {
        console.error('Failed to parse Gemini response:', error);
        console.error('Response text:', cleanedText);
        throw new Error('Failed to parse AI analysis response');
    }
}

/**
 * Main function to perform clinical analysis
 */
export async function performClinicalAnalysis(
    patient: Patient,
    encounter: ClinicalEncounter,
    history: MedicalHistory | null,
    labResults: LaboratoryPanel[],
    apiKey: string
): Promise<DiagnosticAnalysis> {
    const prompt = buildAnalysisPrompt(patient, encounter, history, labResults);

    const startTime = Date.now();
    const responseText = await callGeminiAPI(prompt, apiKey);
    const processingTime = Date.now() - startTime;

    const analysis = parseAnalysisResponse(responseText, encounter.id);

    // Add processing time to audit trail
    analysis.auditTrail.push({
        id: generateAuditId(),
        timestamp: new Date(),
        action: 'ai-analysis-viewed',
        actorId: 'system',
        actorRole: 'AI Engine',
        resourceType: 'DiagnosticAnalysis',
        resourceId: analysis.id,
        details: `Analysis completed in ${processingTime}ms`,
    });

    return analysis;
}

/**
 * Extract symptoms from free-text using Gemini
 */
export async function extractSymptomsFromText(
    text: string,
    apiKey: string
): Promise<Symptom[]> {
    const prompt = `You are a medical NLP expert. Extract symptoms from the following patient description and return them in a structured JSON format.

Patient description:
"${text}"

Return a JSON array of symptoms with the following structure:
[
  {
    "name": "Symptom name (standardized medical term)",
    "description": "Brief description based on patient's words",
    "onset": "sudden|gradual|unknown",
    "duration": "Duration if mentioned (e.g., '3 days', '1 week')",
    "severity": 5,
    "location": "Body location if mentioned",
    "characteristics": ["Any characteristics mentioned"]
  }
]

Guidelines:
- Use standardized medical terminology for symptom names
- Preserve the patient's description details
- Estimate severity 1-10 based on description language
- Only include symptoms explicitly mentioned or strongly implied
- Return empty array if no symptoms found

Respond ONLY with the JSON array, no additional text.`;

    const responseText = await callGeminiAPI(prompt, apiKey);

    // Clean up response
    let cleanedText = responseText.trim();
    if (cleanedText.startsWith('```json')) {
        cleanedText = cleanedText.slice(7);
    }
    if (cleanedText.startsWith('```')) {
        cleanedText = cleanedText.slice(3);
    }
    if (cleanedText.endsWith('```')) {
        cleanedText = cleanedText.slice(0, -3);
    }

    try {
        const parsed = JSON.parse(cleanedText.trim());
        return parsed.map((s: any) => ({
            id: generateId(),
            name: s.name || 'Unknown symptom',
            description: s.description,
            onset: s.onset || 'unknown',
            duration: s.duration || 'Not specified',
            severity: Math.min(10, Math.max(1, s.severity || 5)),
            location: s.location,
            characteristics: s.characteristics,
            nlpExtracted: true,
            confidence: 0.85, // Default confidence for extracted symptoms
        }));
    } catch (error) {
        console.error('Failed to parse symptoms:', error);
        return [];
    }
}
